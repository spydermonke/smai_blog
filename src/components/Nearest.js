import React from 'react'
import kmeans from '../resources/online_agglomerative_clustering.png'
import sklearn from '../resources/sklearn_agglomerative_clustering.png'
// import kmeanvideo from '../resources/k-means_video.mp4'
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { dark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import './styles.css';

function Nearest() {
    const pythonCode = `class OnlineAggClustering:
    def __init__(self, k, random_state=42):
        self.k = k
        self.centroids = None
        self.cluster_counts = None
        np.random.seed(random_state)

    def fit(self, X):
        self.centroids = X[np.random.choice(X.shape[0], self.k, replace=False)]
        self.cluster_counts = np.ones(self.k)

    def update(self, new_point):
        # add point as new cluster
        self.centroids = np.vstack([self.centroids, new_point])
        self.cluster_counts = np.append(self.cluster_counts, 1)

        # calculate distance between every pair of clusters
        # store the pair of centroids with smallest distance
        # merge the two clusters with smallest distance
        # repeat until k clusters remain
        while len(self.centroids) > self.k:
            cluster_distances = np.zeros((len(self.centroids), len(self.centroids)))
            for i in range(len(self.centroids)):
                for j in range(len(self.centroids)):
                    cluster_distances[i, j] = np.sqrt(np.sum((self.centroids[i] - self.centroids[j])**2))
            np.fill_diagonal(cluster_distances, np.inf) # set diagonal to infinity so we don't merge a cluster with itself
            c1, c2 = np.unravel_index(cluster_distances.argmin(), cluster_distances.shape) # find the indices of the smallest distance
            self.centroids[c1] = 1.0 / (self.cluster_counts[c1] + self.cluster_counts[c2]) * (self.cluster_counts[c1] * self.centroids[c1] + self.cluster_counts[c2] * self.centroids[c2])
            self.cluster_counts[c1] += self.cluster_counts[c2]
            self.centroids = np.delete(self.centroids, c2, axis=0)
            self.cluster_counts = np.delete(self.cluster_counts, c2, axis=0)

    def plot_clusters(self, X):
        plt.scatter(X[:, 0], X[:, 1], c=np.argmin(np.linalg.norm(X[:, np.newaxis] - self.centroids, axis=2), axis=1), cmap='viridis')
        plt.title("Online Agglomerative Clustering")
        plt.xlabel("Sepal Length (cm)")
        plt.ylabel("Sepal Width (cm)")

        # Plot the cluster centers
        plt.scatter(self.centroids[:, 0], self.centroids[:, 1], c='red', s=200, label='Cluster Centers')
        plt.legend()
        plt.show()`;

    return (
        <div className='m-5 p-3 intro-container bg-light '
            style={{
                border: '1px solid #ccc',
                borderRadius: '10px',
                transition: 'box-shadow 0.3s, transform 0.3s',
                cursor: 'pointer', // Optional: Add a pointer cursor to indicate interactivity
            }}
            onMouseOver={(e) => {
                e.currentTarget.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.1)';
                e.currentTarget.style.transform = 'scale(1.05)';
            }}
            onMouseOut={(e) => {
                e.currentTarget.style.boxShadow = 'none';
                e.currentTarget.style.transform = 'scale(1)';
            }}>
            <h2>Sequential agglomerative clustering.</h2>
            <h3>Incremental agglomerative Clustering</h3>
            <h4>Agglomerative Clustering: Unveiling Incremental Variants</h4>

            <p>
                Within the realm of clustering algorithms, agglomerative procedures stand out as a fascinating family, offering
                hierarchical clustering solutions. One notable variant is the single-linkage algorithm [11], and when applied in
                batch mode to n data points, it produces a hierarchical clustering encompassing all n points.
            </p>

            <p>
                The hierarchy generated by agglomerative procedures can be tailored to specific needs by truncating it at an
                intermediate k-clustering, resulting in a tree structure with k leaves. What's more, there exists a natural scheme
                for incrementally updating these leaves, giving rise to the sequential agglomerative clustering algorithm.
            </p>

            <h5>Algorithm 2.3: Sequential Agglomerative Clustering</h5>
            <p className='container d-flex justify-content-center align-items-center'>
               <p>
                <strong>Set T to the first k data points</strong><br />
                <br />
                <strong>Repeat:</strong>
                <br />
                1. Get the next point x and add it to T
                <br />
                2. Select t, t' âˆˆ T for which dist(t, t') is smallest
                <br />
                3. Replace t, t' by the single center merge(t, t')
            </p>
            </p>

            <p>
                In this algorithm, the functions dist and merge can be customized to optimize different clustering criteria.
                Depending on the application, these functions might require storing additional sufficient statistics, such as
                counts of individual clusters.
            </p>

            <p>
                One illustrative example is Ward's method of average linkage [18], which is designed to align with the k-means
                cost function. The variant considered here sets dist(t, t') = d(t, t') and merge(t, t') to either t or t'.
            </p>

            <p>
                Agglomerative clustering, particularly in its incremental form, opens up possibilities for dynamic and adaptive
                clustering, catering to various optimization goals and criteria.
            </p>
            <div className='container  d-flex justify-content-center align-items-center border bg-dark rounded '>
                <pre>
                   <SyntaxHighlighter language="python">
                    {pythonCode}
                </SyntaxHighlighter>
                </pre>
            </div>
            <div className='d-flex' >
                <img className='pt-4 pb-4' src={kmeans} alt="kmeans" />
                <img className='p-4' src={sklearn} alt="sklearn" />

            </div>
            {/* <div className='container  d-flex justify-content-center align-items-center '>
                <video width="640" height="740" controls>
                    <source src={kmeanvideo} type="video/mp4" />
                </video>
            </div> */}
        </div>
    )
}

export default Nearest